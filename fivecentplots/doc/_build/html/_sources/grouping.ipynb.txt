{
 "cells": [
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "# Grouping data"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "A single pandas DataFrame can often be decomposed into smaller subsets of data that need to be visualized.  <b><font color=\"blue\" style=\"font-family:'Courier New'\">fivecentplots </font></b> contains multiple grouping levels to expose unique subsets of data:\n",
    "<ul>\n",
    "<li><font style=\"font-family:'Courier New'\">legend</font>: color lines and markers according to unique values in a DataFrame column</li>\n",
    "<li><font style=\"font-family:'Courier New'\">groups</font>:</li>\n",
    "<ul>\n",
    "<li>for xy plots: separates unique subsets so plot lines are not continuously looped back to the origin (useful for replicates of similar data)</li>\n",
    "<li>for boxplots: groups boxes by unique values in one or more DataFrame columns</li>\n",
    "</ul>\n",
    "<li><font style=\"font-family:'Courier New'\">row | column</font>: makes a grid of subplots for each unique value of the DataFrame column names specified for these keyword arguments within a single figure</li>\n",
    "<li><font style=\"font-family:'Courier New'\">wrap</font>: \n",
    "<ul>\n",
    "<li>Option 1: similar to row and column grouping, wrap makes a grid of subplots for each <i>unique value</i> of the DataFrame column names specified for these keyword arguments within a single figure</li>\n",
    "<li>Option 2: wrap by `x` or `y` to create a uniqe subplot for each <i>column name</i> listed</li>\n",
    "</ul>\n",
    "<li><font style=\"font-family:'Courier New'\">figure</font>:  makes a unique figure for each unique value of a DataFrame column</li>\n",
    "</ul>\n",
    "\n",
    "It is also possible to filter data inline sets via the keyword <font style=\"font-family:'Courier New'\">filter</font>.  "
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Setup"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### Imports"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 1,
   "metadata": {},
   "outputs": [],
   "source": [
    "%load_ext autoreload\n",
    "%autoreload 2\n",
    "%matplotlib inline\n",
    "import fivecentplots as fcp\n",
    "import pandas as pd\n",
    "import numpy as np\n",
    "import os, sys, pdb\n",
    "osjoin = os.path.join\n",
    "st = pdb.set_trace"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### Sample data"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 2,
   "metadata": {},
   "outputs": [],
   "source": [
    "df1 = pd.read_csv(osjoin(os.path.dirname(fcp.__file__), 'tests', 'fake_data.csv'))\n",
    "df2 = pd.read_csv(osjoin(os.path.dirname(fcp.__file__), 'tests', 'fake_data_box.csv'))"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## legend"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "The `legend` keyword can be a single DataFrame column name or a list of column names.  The data set will then be grouped according to each unique value of the `legend` column and a separate plot for each value will be added to the figure.  A different color and marker type will be used to display each value."
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### Single legend column"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "In our sample data set, we have repeats of the same current vs. voltage measurement at three different \"Die\" locations.  By setting the `legend` keyword equal to the name of the DataFrame column containing the \"Die\" value, we can distinctly visualize the measurement for each site."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 3,
   "metadata": {},
   "outputs": [
    {
     "ename": "TypeError",
     "evalue": "'NoneType' object is not subscriptable",
     "output_type": "error",
     "traceback": [
      "\u001b[1;31m---------------------------------------------------------------------------\u001b[0m",
      "\u001b[1;31mTypeError\u001b[0m                                 Traceback (most recent call last)",
      "\u001b[1;32m<ipython-input-3-ba685f2709f9>\u001b[0m in \u001b[0;36m<module>\u001b[1;34m()\u001b[0m\n\u001b[0;32m      1\u001b[0m fcp.plot(df=df1, x='Voltage', y='I [A]', legend='Die', \n\u001b[1;32m----> 2\u001b[1;33m          filter='Substrate==\"Si\" & Target Wavelength==450 & Boost Level==0.2 & Temperature [C]==25')\n\u001b[0m",
      "\u001b[1;32mC:\\GitHub\\fivecentplots\\fivecentplots\\fcp.py\u001b[0m in \u001b[0;36mplot\u001b[1;34m(*args, **kwargs)\u001b[0m\n\u001b[0;32m    220\u001b[0m \u001b[1;32mdef\u001b[0m \u001b[0mplot\u001b[0m\u001b[1;33m(\u001b[0m\u001b[1;33m*\u001b[0m\u001b[0margs\u001b[0m\u001b[1;33m,\u001b[0m \u001b[1;33m**\u001b[0m\u001b[0mkwargs\u001b[0m\u001b[1;33m)\u001b[0m\u001b[1;33m:\u001b[0m\u001b[1;33m\u001b[0m\u001b[0m\n\u001b[0;32m    221\u001b[0m \u001b[1;33m\u001b[0m\u001b[0m\n\u001b[1;32m--> 222\u001b[1;33m     \u001b[1;32mreturn\u001b[0m \u001b[0mplotter\u001b[0m\u001b[1;33m(\u001b[0m\u001b[1;34m'plot_xy'\u001b[0m\u001b[1;33m,\u001b[0m \u001b[1;33m**\u001b[0m\u001b[0mdfkwarg\u001b[0m\u001b[1;33m(\u001b[0m\u001b[0margs\u001b[0m\u001b[1;33m,\u001b[0m \u001b[0mkwargs\u001b[0m\u001b[1;33m)\u001b[0m\u001b[1;33m)\u001b[0m\u001b[1;33m\u001b[0m\u001b[0m\n\u001b[0m\u001b[0;32m    223\u001b[0m \u001b[1;33m\u001b[0m\u001b[0m\n\u001b[0;32m    224\u001b[0m \u001b[1;33m\u001b[0m\u001b[0m\n",
      "\u001b[1;32mC:\\GitHub\\fivecentplots\\fivecentplots\\fcp.py\u001b[0m in \u001b[0;36mplotter\u001b[1;34m(plot_func, **kwargs)\u001b[0m\n\u001b[0;32m    634\u001b[0m \u001b[1;33m\u001b[0m\u001b[0m\n\u001b[0;32m    635\u001b[0m     \u001b[1;31m# Iterate over discrete figures\u001b[0m\u001b[1;33m\u001b[0m\u001b[1;33m\u001b[0m\u001b[0m\n\u001b[1;32m--> 636\u001b[1;33m     \u001b[1;32mfor\u001b[0m \u001b[0mifig\u001b[0m\u001b[1;33m,\u001b[0m \u001b[0mfig_item\u001b[0m\u001b[1;33m,\u001b[0m \u001b[0mfig_cols\u001b[0m\u001b[1;33m,\u001b[0m \u001b[0mdf_fig\u001b[0m \u001b[1;32min\u001b[0m \u001b[0mdd\u001b[0m\u001b[1;33m.\u001b[0m\u001b[0mget_df_figure\u001b[0m\u001b[1;33m(\u001b[0m\u001b[1;33m)\u001b[0m\u001b[1;33m:\u001b[0m\u001b[1;33m\u001b[0m\u001b[0m\n\u001b[0m\u001b[0;32m    637\u001b[0m         \u001b[1;31m# Create a layout object\u001b[0m\u001b[1;33m\u001b[0m\u001b[1;33m\u001b[0m\u001b[0m\n\u001b[0;32m    638\u001b[0m         \u001b[0mlayout\u001b[0m \u001b[1;33m=\u001b[0m \u001b[0mLAYOUT\u001b[0m\u001b[1;33m[\u001b[0m\u001b[0mengine\u001b[0m\u001b[1;33m]\u001b[0m\u001b[1;33m(\u001b[0m\u001b[0mplot_func\u001b[0m\u001b[1;33m,\u001b[0m \u001b[1;33m**\u001b[0m\u001b[0mkwargs\u001b[0m\u001b[1;33m)\u001b[0m\u001b[1;33m\u001b[0m\u001b[0m\n",
      "\u001b[1;32mC:\\GitHub\\fivecentplots\\fivecentplots\\data.py\u001b[0m in \u001b[0;36mget_df_figure\u001b[1;34m(self)\u001b[0m\n\u001b[0;32m    880\u001b[0m             \u001b[0mself\u001b[0m\u001b[1;33m.\u001b[0m\u001b[0mdf_fig\u001b[0m \u001b[1;33m=\u001b[0m \u001b[0mself\u001b[0m\u001b[1;33m.\u001b[0m\u001b[0mdf_all\u001b[0m\u001b[1;33m\u001b[0m\u001b[0m\n\u001b[0;32m    881\u001b[0m             \u001b[0mself\u001b[0m\u001b[1;33m.\u001b[0m\u001b[0mtrans_df_rc\u001b[0m \u001b[1;33m=\u001b[0m \u001b[1;32mFalse\u001b[0m\u001b[1;33m\u001b[0m\u001b[0m\n\u001b[1;32m--> 882\u001b[1;33m             \u001b[1;32mfor\u001b[0m \u001b[0mir\u001b[0m\u001b[1;33m,\u001b[0m \u001b[0mic\u001b[0m\u001b[1;33m,\u001b[0m \u001b[0mdf_rc\u001b[0m \u001b[1;32min\u001b[0m \u001b[0mself\u001b[0m\u001b[1;33m.\u001b[0m\u001b[0mget_rc_subset\u001b[0m\u001b[1;33m(\u001b[0m\u001b[0mself\u001b[0m\u001b[1;33m.\u001b[0m\u001b[0mdf_fig\u001b[0m\u001b[1;33m,\u001b[0m \u001b[1;32mTrue\u001b[0m\u001b[1;33m)\u001b[0m\u001b[1;33m:\u001b[0m\u001b[1;33m\u001b[0m\u001b[0m\n\u001b[0m\u001b[0;32m    883\u001b[0m                 \u001b[1;32mcontinue\u001b[0m\u001b[1;33m\u001b[0m\u001b[0m\n\u001b[0;32m    884\u001b[0m             \u001b[1;32myield\u001b[0m \u001b[1;32mNone\u001b[0m\u001b[1;33m,\u001b[0m \u001b[1;32mNone\u001b[0m\u001b[1;33m,\u001b[0m \u001b[1;32mNone\u001b[0m\u001b[1;33m,\u001b[0m \u001b[0mself\u001b[0m\u001b[1;33m.\u001b[0m\u001b[0mdf_fig\u001b[0m\u001b[1;33m\u001b[0m\u001b[0m\n",
      "\u001b[1;32mC:\\GitHub\\fivecentplots\\fivecentplots\\data.py\u001b[0m in \u001b[0;36mget_rc_subset\u001b[1;34m(self, df, ranges)\u001b[0m\n\u001b[0;32m   1250\u001b[0m                         \u001b[0mself\u001b[0m\u001b[1;33m.\u001b[0m\u001b[0mdf_rc\u001b[0m \u001b[1;33m=\u001b[0m \u001b[0mdf\u001b[0m\u001b[1;33m[\u001b[0m\u001b[1;33m(\u001b[0m\u001b[0mdf\u001b[0m\u001b[1;33m[\u001b[0m\u001b[0mself\u001b[0m\u001b[1;33m.\u001b[0m\u001b[0mcol\u001b[0m\u001b[1;33m[\u001b[0m\u001b[1;36m0\u001b[0m\u001b[1;33m]\u001b[0m\u001b[1;33m]\u001b[0m \u001b[1;33m==\u001b[0m \u001b[0mcol\u001b[0m\u001b[1;33m)\u001b[0m\u001b[1;33m]\u001b[0m\u001b[1;33m.\u001b[0m\u001b[0mcopy\u001b[0m\u001b[1;33m(\u001b[0m\u001b[1;33m)\u001b[0m\u001b[1;33m\u001b[0m\u001b[0m\n\u001b[0;32m   1251\u001b[0m                     \u001b[1;32melif\u001b[0m \u001b[0mself\u001b[0m\u001b[1;33m.\u001b[0m\u001b[0mcol\u001b[0m \u001b[1;33m!=\u001b[0m \u001b[1;34m'x'\u001b[0m \u001b[1;32mand\u001b[0m \u001b[0mself\u001b[0m\u001b[1;33m.\u001b[0m\u001b[0mrow\u001b[0m \u001b[1;32min\u001b[0m \u001b[1;33m[\u001b[0m\u001b[1;32mNone\u001b[0m\u001b[1;33m,\u001b[0m \u001b[1;34m'y'\u001b[0m\u001b[1;33m]\u001b[0m\u001b[1;33m:\u001b[0m\u001b[1;33m\u001b[0m\u001b[0m\n\u001b[1;32m-> 1252\u001b[1;33m                         \u001b[0mcol\u001b[0m \u001b[1;33m=\u001b[0m \u001b[0mself\u001b[0m\u001b[1;33m.\u001b[0m\u001b[0mcol_vals\u001b[0m\u001b[1;33m[\u001b[0m\u001b[0mic\u001b[0m\u001b[1;33m]\u001b[0m\u001b[1;33m\u001b[0m\u001b[0m\n\u001b[0m\u001b[0;32m   1253\u001b[0m                         \u001b[0mself\u001b[0m\u001b[1;33m.\u001b[0m\u001b[0mdf_rc\u001b[0m \u001b[1;33m=\u001b[0m \u001b[0mdf\u001b[0m\u001b[1;33m[\u001b[0m\u001b[1;33m(\u001b[0m\u001b[0mdf\u001b[0m\u001b[1;33m[\u001b[0m\u001b[0mself\u001b[0m\u001b[1;33m.\u001b[0m\u001b[0mcol\u001b[0m\u001b[1;33m[\u001b[0m\u001b[1;36m0\u001b[0m\u001b[1;33m]\u001b[0m\u001b[1;33m]\u001b[0m \u001b[1;33m==\u001b[0m \u001b[0mcol\u001b[0m\u001b[1;33m)\u001b[0m\u001b[1;33m]\u001b[0m\u001b[1;33m.\u001b[0m\u001b[0mcopy\u001b[0m\u001b[1;33m(\u001b[0m\u001b[1;33m)\u001b[0m\u001b[1;33m\u001b[0m\u001b[0m\n\u001b[0;32m   1254\u001b[0m                     \u001b[1;32melif\u001b[0m \u001b[0mself\u001b[0m\u001b[1;33m.\u001b[0m\u001b[0mcol\u001b[0m \u001b[1;32min\u001b[0m \u001b[1;33m[\u001b[0m\u001b[1;32mNone\u001b[0m\u001b[1;33m,\u001b[0m \u001b[1;34m'x'\u001b[0m\u001b[1;33m]\u001b[0m \u001b[1;32mand\u001b[0m \u001b[0mself\u001b[0m\u001b[1;33m.\u001b[0m\u001b[0mrow\u001b[0m \u001b[1;33m!=\u001b[0m \u001b[1;34m'y'\u001b[0m\u001b[1;33m:\u001b[0m\u001b[1;33m\u001b[0m\u001b[0m\n",
      "\u001b[1;31mTypeError\u001b[0m: 'NoneType' object is not subscriptable"
     ]
    }
   ],
   "source": [
    "fcp.plot(df=df1, x='Voltage', y='I [A]', legend='Die', \n",
    "         filter='Substrate==\"Si\" & Target Wavelength==450 & Boost Level==0.2 & Temperature [C]==25')"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### Multiple legend columns"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "<b><font color=\"blue\" style=\"font-family:'Courier New'\">fivecentplots </font></b> also supports legending by multiple DataFrame columns.  When a list of column names is passed to the `legend` keyword, a dummy column is created in the DataFrame that concatenates the values from each column listed in `legend`.  This new column is used for legending."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "fcp.plot(df=df1, x='Voltage', y='I [A]', legend=['Die', 'Substrate'], \\\n",
    "         filter='Target Wavelength==450 & Boost Level==0.2 & Temperature [C]==25')"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### Multiple x & y values "
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "When plotting more than one DataFrame column on the y axis <i>without</i> a specific grouping column, a legend is also enabled to improve visualization of the data.  The legend can be disabled by setting `legend=False`."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "fcp.plot(df=df1, x='Voltage', y=['I [A]', 'Voltage'], lines=False, \n",
    "         filter='Substrate==\"Si\" & Target Wavelength==450 & Boost Level==0.2')"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### Secondary x|y plots"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Three options are available for legending are available for plots with a secondary axis: (1) no legend; (2) legend based on the values of the primary/secondary axes; or (3) legend based on another column."
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "#### No legend"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "fcp.plot(df1, x='Voltage', y=['Voltage', 'I [A]'], twin_x=True, \n",
    "         filter='Substrate==\"Si\" & Target Wavelength==450 & Boost Level==0.2 & Temperature [C]==25 & Die==\"(-1,2)\"')"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "#### Axis legend"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "fcp.plot(df1, x='Voltage', y=['Voltage', 'I [A]'], twin_x=True, legend=True,\n",
    "         filter='Substrate==\"Si\" & Target Wavelength==450 & Boost Level==0.2 & Temperature [C]==25 & Die==\"(-1,2)\"')"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "#### Legend by another column"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "fcp.plot(df1, x='Voltage', y=['Voltage', 'I [A]'], twin_x=True, legend='Die',\n",
    "         filter='Substrate==\"Si\" & Target Wavelength==450 & Boost Level==0.2 & Temperature [C]==25 & Die==\"(-1,2)\"')"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## groups"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "The `groups` keyword requires a column name or list of column names from the DataFrame.  These columns are used to identify subsets in the data and make sure they are properly visualize in the plot.  Unlike `legend`, group values are not added to a legend on the plot."
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### xy plots"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Some data sets contain multiple sets of similar data.  Consider the following example where we  plot all the data together and connect the points with lines.  Notice how the line loops from the end of the data back to the begining for each \"group\" of the data.  This occurs because we have provided no information about how to segment the data set."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "fcp.plot(df=df1, x='Voltage', y='I [A]', legend='Temperature [C]', \\\n",
    "         filter='Substrate==\"Si\" & Target Wavelength==450 & Boost Level==0.2')"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "To handle cases like this, we can add the keyword `groups` and specify another DataFrame column name that indicates how the data are grouped (in this case by \"Die\").  Now we get distinct lines for each instance of the measurement data.  The `groups` keyword can still be combined with a legend from a different DataFrame column."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "fcp.plot(df=df1, x='Voltage', y='I [A]', groups='Die', legend='Temperature [C]', \\\n",
    "         filter='Substrate==\"Si\" & Target Wavelength==450 & Boost Level==0.2')"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "`groups` also supports multiple column names.  Here is the above plot without legending by \"Temperature [C]\":"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "fcp.plot(df=df1, x='Voltage', y='I [A]', groups=['Die', 'Temperature [C]'], \n",
    "         filter='Substrate==\"Si\" & Target Wavelength==450 & Boost Level==0.2')"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### boxplots"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Like x-y plots, the `groups` keyword is used to break the data set into subsets.  However, for boxplots the group column names and values are actually displayed along the x-axis:"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "df_box = pd.read_csv(osjoin(os.path.dirname(fcp.__file__), 'tests', 'fake_data_box.csv'))\n",
    "fcp.boxplot(df=df_box, y='Value', groups=['Batch', 'Sample'], legend='Region')"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## row | col subplots"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### By unique values"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "To see a larger subset of the main DataFrame, we can make a grid of subplots based on the unique values within DataFrame columns <i>other than the primary x and y columns we are using</i>.  In this case, we remove the \"Temperature [C]\" and \"Boost Level\" columns from the <font style=\"font-family:'Courier New'\">filter</font> keyword and add them to the <font style=\"font-family:'Courier New'\">row</font> and <font style=\"font-family:'Courier New'\">column</font> commands, respectively.  This gives a grid of plots where each plot represents the intersection of a unique Boost Level and Temperature."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "fcp.plot(df=df1, x='Voltage', y='I [A]', legend='Die', col='Boost Level', row='Temperature [C]', \\\n",
    "         ax_size=[225, 225], filter='Substrate==\"Si\" & Target Wavelength==450', label_rc_font_size=14)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### By x or y"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Alternatively, we can use row vs column grids to compare different `x` or `y` values.  For example, we can plot two y-columns (one per row) by adding the keyword `\"y\"` to the `row` parameter.  Each column in this plot shares the same x-axis variable."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "fcp.plot(df=df1, x='Voltage', y=['Voltage', 'I [A]'], legend='Die', col='Boost Level', row='y', \n",
    "         ax_size=[225, 225], filter='Substrate==\"Si\" & Target Wavelength==450 & Temperature [C]==75', label_rc_font_size=14)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "We can make a similar plot with common `row` values and different x-axes by setting `col='x'`:"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "fcp.plot(df=df1, x=['Voltage', 'I [A]'], y='Voltage', legend='Die', row='Boost Level', col='x', \n",
    "         ax_size=[225, 225], filter='Substrate==\"Si\" & Target Wavelength==450 & Temperature [C]==75', label_rc_font_size=14)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## wrap subplots"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### By unique values"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "We can create a plot similar to the row/column plot above using the `wrap` keyword.  The key differences are that spacing and ticks between subplots is removed by default (can be changed via keywords), axis sharing is forced (cannot override), and the row/column value labels are condensed to a single label above each subplot.  To do this, remove the `row` and `column` keywords from the previous function call and pass the \"Temperature [C]\" and \"Boost Level\" column names as a list to the `wrap` keyword."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "fcp.plot(df=df1, x='Voltage', y='I [A]', legend='Die', wrap=['Temperature [C]', 'Boost Level'], \\\n",
    "         ax_size=[225, 225], filter='Substrate==\"Si\" & Target Wavelength==450')"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "By default, wrap plots will be arranged in a square grid.  If the number of subplots does not match a perfectly square grid, you will have an incomplete row of subplots in the grid.  All tick and axes labels are handled appropriately for this case.  If you want to override the default grid size, specify the keyword `ncol` which sets the number of columns.  The number of rows will be automatically determined from the number of subplots."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "fcp.plot(df=df1, x='Voltage', y='I [A]', legend='Die', wrap=['Temperature [C]', 'Boost Level'], \\\n",
    "         ax_size=[225, 225], filter='Substrate==\"Si\" & Target Wavelength==450', ncol=2)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### By x and y"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "We can also \"wrap\" by column names instead of unique column values.  In this case we list the columns to plot in the `x` or `y` keywords as usual but we add \"x\" or \"y\" to the `wrap` keyword.  This will create a unique subplot in a grid for \n",
    "each `wrap` value.  Unlike the case of wrapping column values, this plot will not have wrap labels and axis sharing can be overriden.  As before, used `ncol` to override the default gridding.  Unlike a row vs column plot by x and y, a wrap plot by x and y can be displayed without the extra grouping factor. "
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "fcp.plot(df=df1, x='Voltage', y=['I Set', 'I [A]'], legend='Die', wrap='y', \n",
    "         groups=['Boost Level', 'Temperature [C]'], ax_size=[325, 325], \n",
    "         filter='Substrate==\"Si\" & Target Wavelength==450')"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Or an alternatively styled version of this plot with tick and label sharing off:"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "fcp.plot(df=df1, x='Voltage', y=['I Set', 'I [A]'], legend='Die', wrap='y', \n",
    "         groups=['Boost Level', 'Temperature [C]'], ax_size=[525, 170], \n",
    "         filter='Substrate==\"Si\" & Target Wavelength==450', ncol=1, ws_row=0, \n",
    "         separate_labels=False, separate_ticks=False)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## figure plots"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "collapsed": true
   },
   "source": [
    "To add another dimension of grouping, <b><font color=\"blue\" style=\"font-family:'Courier New'\">fivecentplots </font></b> supports grouping by figure.  In this case, a separate figure (i.e., a separate png) is created for each unique value in the DataFrame column(s) listed in the `fig_groups` keyword.  Here we will plot a single figure for each value of the \"Die\" column."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "fcp.plot(df=df1, x='Voltage', y='I [A]', fig_groups='Die', wrap=['Temperature [C]', 'Boost Level'], \\\n",
    "         ax_size=[225, 225], filter='Substrate==\"Si\" & Target Wavelength==450', show_filename=True,\n",
    "         filename=r'C:\\GitHub\\fivecentplots\\fivecentplots\\tests\\test_images\\grouping.py\\figure.png')"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": []
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Python 3",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.6.4"
  },
  "toc": {
   "nav_menu": {},
   "number_sections": true,
   "sideBar": true,
   "skip_h1_title": true,
   "toc_cell": false,
   "toc_position": {
    "height": "790px",
    "left": "0px",
    "right": "1161px",
    "top": "120px",
    "width": "212px"
   },
   "toc_section_display": "block",
   "toc_window_display": true
  }
 },
 "nbformat": 4,
 "nbformat_minor": 1
}
